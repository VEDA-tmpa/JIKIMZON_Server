# **StorageManager 클래스 설계**

## **1. 생성자**
- **역할**: 
  - 카메라 객체(IP)를 받아오고, 최대 크기 및 버퍼 최대 크기를 설정합니다.
  - 저장소 초기화 메서드 `initializeStorage()`를 호출합니다.

---

## **2. initializeStorage()**
- **역할**: 저장 공간 초기화를 담당합니다.
### (1) **경로 설정**
- `mStoragePath`: 저장 디렉토리 경로 생성.
- `mVideoPath`: 비디오 데이터가 저장될 파일 경로 생성.

### (2) **저장 디렉토리 생성**
- 경로가 없으면 새 디렉토리 생성.
- 디렉토리가 이미 존재하면 아무 작업도 수행하지 않음.

### (3) **비디오 파일 확인 및 처리**
- 새로운 환경에서는 초기화, 기존 환경에서는 데이터 복구 후 작업 지속.

#### 1) 파일이 없을 경우:
- 새로운 비디오 파일 생성.
- 헤더(`mHeader`) 초기화: `{0, 0, 0}`으로 설정.
- `updateHeader()`를 호출하여 초기 헤더를 파일에 저장.

#### 2) 파일이 있을 경우:
- `loadHeader()`를 호출하여 기존 헤더 파일에서 상태를 복구.

---

## **3. updateHeader()**
- **역할**: 
  - `mHeader`에 저장된 현재 버퍼 상태를 `mVideoPath` 파일에 기록하여 동기화.
  - 순환 버퍼의 상태를 유지하도록 지원.

### (1) 파일 열기
- `mVideoPath` 경로의 파일을 **바이너리 모드**로 열고, `std::ios::trunc` 옵션을 사용하여 내용을 덮어씌움.

### (2) 헤더 데이터 쓰기
- `reinterpret_cast<const char*>`를 사용해 구조체 데이터를 바이트 배열로 변환하여 기록.
- `sizeof(video::HeaderStruct)`를 사용해 구조체 크기만큼 데이터를 정확히 기록.

### (3) 파일 닫기
- 데이터를 파일에 쓰고 리소스를 해제.

---

## **4. loadHeader()**
- **역할**: 저장된 헤더 파일에서 순환 버퍼의 상태를 복구.

### (1) 파일 열기
- `mVideoPath` 경로의 파일을 **바이너리 모드**로 열어 데이터 복구.

### (2) 헤더 데이터 읽기
- `file.read()`로 헤더 데이터를 읽어 버퍼에 저장.

### (3) 데이터 검증 및 복구
- `file.gcount()`로 읽은 데이터 크기를 확인하고 구조체 크기와 비교.
- `Deserialize()`를 사용해 읽어온 바이너리 데이터를 복구.

---

## **5. SaveFrame()**
- **역할**: 
  - 프레임 직렬화 및 크기 확인.
  - 공간 부족 시 오래된 데이터 삭제.
  - 순환 버퍼에 데이터를 저장하고 헤더를 업데이트.

### (1) 프레임 직렬화 및 크기 계산
- `frame.Serialize(serializedFrame)`을 호출해 직렬화된 프레임 크기 계산.

### (2) 프레임 크기 확인
- `frameSize > mMaximumSize`이면 저장하지 않고 예외 처리.

### (3) 저장 공간 계산 및 확보
- `getRemainSpace()`를 호출해 공간 부족 여부 확인.
- 오래된 프레임 삭제 후 공간 확보.

### (4) 데이터 저장
- 직렬화된 프레임 데이터를 버퍼에 연속적으로 복사.

### (5) 헤더 업데이트
- `currentIndex` 및 `endIndex`를 업데이트.
- `updateHeader()` 호출로 상태 동기화.

---

## **6. GetNextFrame()**
- **역할**: 
  - 버퍼에서 `currentIndex` 위치의 프레임을 읽고 복원.
  - 다음 프레임의 시작 위치로 `currentIndex`를 업데이트.

### (1) 프레임 존재 여부 확인
- `mHeader.currentIndex == mHeader.endIndex`인 경우 데이터 없음.

### (2) 프레임 크기 확인
- `getFrameSizeAt(mHeader.currentIndex)`를 호출해 프레임 크기 계산.

### (3) 데이터 읽기
- 데이터를 `serializedFrame` 버퍼로 복사.

### (4) 프레임 복원
- `Deserialize()`를 호출해 직렬화된 데이터를 복원.

### (5) 읽기 위치 업데이트
- `currentIndex`를 읽은 프레임 크기만큼 이동. 순환 구조를 반영해 모듈 연산 사용.

---

## **7. addPadding()**
- **역할**: 
  - 지정된 `start`에서 `end`까지 버퍼 데이터를 0으로 초기화.

### (1) 구간 비교
#### 1) `end > start`:
- 패딩 구간이 연속적일 경우 처리.

#### 2) `end <= start`:
- 패딩 구간이 순환 구조일 경우 처리.

---

## **8. getRemainSpace()**
- **역할**: 
  - 순환 버퍼에서 남은 공간 크기 계산.

### (1) 버퍼가 비어 있는 경우:
- `startIndex == endIndex`인 경우 남은 공간은 전체 크기.

### (2) 데이터가 연속적으로 저장된 경우:
- `endIndex > startIndex`일 때 남은 공간 계산.

---

## **9. getFrameSizeAt()**
- **역할**: 특정 위치에서 프레임 크기 계산.

### (1) 헤더 데이터 추출
- `readIndex = index % mMaximumSize`로 순환 구조 지원.

### (2) 헤더 디코딩
- `Deserialize()`를 호출해 헤더를 디코딩.

### (3) 프레임 크기 계산
- `header.GetBodySize()`로 헤더와 바디 크기를 합산하여 반환.
